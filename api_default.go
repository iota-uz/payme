/*
Payme Merchant API

API for managing Payme Merchant.

API version: 1.0.0
Contact: danil@iota.uz
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paymeapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type DefaultAPI interface {

	/*
	Canceltransaction CancelTransaction operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultAPICanceltransactionRequest
	*/
	Canceltransaction(ctx context.Context) DefaultAPICanceltransactionRequest

	// CanceltransactionExecute executes the request
	//  @return CancelTransactionResponse
	CanceltransactionExecute(r DefaultAPICanceltransactionRequest) (*CancelTransactionResponse, *http.Response, error)

	/*
	Checkperformtransaction CheckPerformTransaction operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultAPICheckperformtransactionRequest
	*/
	Checkperformtransaction(ctx context.Context) DefaultAPICheckperformtransactionRequest

	// CheckperformtransactionExecute executes the request
	//  @return CheckPerformTransactionResponse
	CheckperformtransactionExecute(r DefaultAPICheckperformtransactionRequest) (*CheckPerformTransactionResponse, *http.Response, error)

	/*
	Checktransaction CheckTransaction operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultAPIChecktransactionRequest
	*/
	Checktransaction(ctx context.Context) DefaultAPIChecktransactionRequest

	// ChecktransactionExecute executes the request
	//  @return CheckTransactionResponse
	ChecktransactionExecute(r DefaultAPIChecktransactionRequest) (*CheckTransactionResponse, *http.Response, error)

	/*
	Createtransaction CreateTransaction operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultAPICreatetransactionRequest
	*/
	Createtransaction(ctx context.Context) DefaultAPICreatetransactionRequest

	// CreatetransactionExecute executes the request
	//  @return CreateTransactionResponse
	CreatetransactionExecute(r DefaultAPICreatetransactionRequest) (*CreateTransactionResponse, *http.Response, error)

	/*
	Getstatement GetStatement operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultAPIGetstatementRequest
	*/
	Getstatement(ctx context.Context) DefaultAPIGetstatementRequest

	// GetstatementExecute executes the request
	//  @return GetStatementResponse
	GetstatementExecute(r DefaultAPIGetstatementRequest) (*GetStatementResponse, *http.Response, error)

	/*
	Performtransaction PerformTransaction operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultAPIPerformtransactionRequest
	*/
	Performtransaction(ctx context.Context) DefaultAPIPerformtransactionRequest

	// PerformtransactionExecute executes the request
	//  @return PerformTransactionResponse
	PerformtransactionExecute(r DefaultAPIPerformtransactionRequest) (*PerformTransactionResponse, *http.Response, error)

	/*
	Setfiscaldata SetFiscalData operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultAPISetfiscaldataRequest
	*/
	Setfiscaldata(ctx context.Context) DefaultAPISetfiscaldataRequest

	// SetfiscaldataExecute executes the request
	//  @return SetFiscalDataResponse
	SetfiscaldataExecute(r DefaultAPISetfiscaldataRequest) (*SetFiscalDataResponse, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type DefaultAPICanceltransactionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	cancelTransactionRequest *CancelTransactionRequest
}

func (r DefaultAPICanceltransactionRequest) CancelTransactionRequest(cancelTransactionRequest CancelTransactionRequest) DefaultAPICanceltransactionRequest {
	r.cancelTransactionRequest = &cancelTransactionRequest
	return r
}

func (r DefaultAPICanceltransactionRequest) Execute() (*CancelTransactionResponse, *http.Response, error) {
	return r.ApiService.CanceltransactionExecute(r)
}

/*
Canceltransaction CancelTransaction operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICanceltransactionRequest
*/
func (a *DefaultAPIService) Canceltransaction(ctx context.Context) DefaultAPICanceltransactionRequest {
	return DefaultAPICanceltransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CancelTransactionResponse
func (a *DefaultAPIService) CanceltransactionExecute(r DefaultAPICanceltransactionRequest) (*CancelTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Canceltransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CancelTransaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cancelTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("cancelTransactionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cancelTransactionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICheckperformtransactionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	checkPerformTransactionRequest *CheckPerformTransactionRequest
}

func (r DefaultAPICheckperformtransactionRequest) CheckPerformTransactionRequest(checkPerformTransactionRequest CheckPerformTransactionRequest) DefaultAPICheckperformtransactionRequest {
	r.checkPerformTransactionRequest = &checkPerformTransactionRequest
	return r
}

func (r DefaultAPICheckperformtransactionRequest) Execute() (*CheckPerformTransactionResponse, *http.Response, error) {
	return r.ApiService.CheckperformtransactionExecute(r)
}

/*
Checkperformtransaction CheckPerformTransaction operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICheckperformtransactionRequest
*/
func (a *DefaultAPIService) Checkperformtransaction(ctx context.Context) DefaultAPICheckperformtransactionRequest {
	return DefaultAPICheckperformtransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckPerformTransactionResponse
func (a *DefaultAPIService) CheckperformtransactionExecute(r DefaultAPICheckperformtransactionRequest) (*CheckPerformTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckPerformTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Checkperformtransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CheckPerformTransaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.checkPerformTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("checkPerformTransactionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.checkPerformTransactionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIChecktransactionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	checkTransactionRequest *CheckTransactionRequest
}

func (r DefaultAPIChecktransactionRequest) CheckTransactionRequest(checkTransactionRequest CheckTransactionRequest) DefaultAPIChecktransactionRequest {
	r.checkTransactionRequest = &checkTransactionRequest
	return r
}

func (r DefaultAPIChecktransactionRequest) Execute() (*CheckTransactionResponse, *http.Response, error) {
	return r.ApiService.ChecktransactionExecute(r)
}

/*
Checktransaction CheckTransaction operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIChecktransactionRequest
*/
func (a *DefaultAPIService) Checktransaction(ctx context.Context) DefaultAPIChecktransactionRequest {
	return DefaultAPIChecktransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckTransactionResponse
func (a *DefaultAPIService) ChecktransactionExecute(r DefaultAPIChecktransactionRequest) (*CheckTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Checktransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CheckTransaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.checkTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("checkTransactionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.checkTransactionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPICreatetransactionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	createTransactionRequest *CreateTransactionRequest
}

func (r DefaultAPICreatetransactionRequest) CreateTransactionRequest(createTransactionRequest CreateTransactionRequest) DefaultAPICreatetransactionRequest {
	r.createTransactionRequest = &createTransactionRequest
	return r
}

func (r DefaultAPICreatetransactionRequest) Execute() (*CreateTransactionResponse, *http.Response, error) {
	return r.ApiService.CreatetransactionExecute(r)
}

/*
Createtransaction CreateTransaction operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPICreatetransactionRequest
*/
func (a *DefaultAPIService) Createtransaction(ctx context.Context) DefaultAPICreatetransactionRequest {
	return DefaultAPICreatetransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateTransactionResponse
func (a *DefaultAPIService) CreatetransactionExecute(r DefaultAPICreatetransactionRequest) (*CreateTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Createtransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/CreateTransaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("createTransactionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createTransactionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIGetstatementRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	getStatementRequest *GetStatementRequest
}

func (r DefaultAPIGetstatementRequest) GetStatementRequest(getStatementRequest GetStatementRequest) DefaultAPIGetstatementRequest {
	r.getStatementRequest = &getStatementRequest
	return r
}

func (r DefaultAPIGetstatementRequest) Execute() (*GetStatementResponse, *http.Response, error) {
	return r.ApiService.GetstatementExecute(r)
}

/*
Getstatement GetStatement operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIGetstatementRequest
*/
func (a *DefaultAPIService) Getstatement(ctx context.Context) DefaultAPIGetstatementRequest {
	return DefaultAPIGetstatementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetStatementResponse
func (a *DefaultAPIService) GetstatementExecute(r DefaultAPIGetstatementRequest) (*GetStatementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStatementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Getstatement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/GetStatement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getStatementRequest == nil {
		return localVarReturnValue, nil, reportError("getStatementRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getStatementRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPIPerformtransactionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	performTransactionRequest *PerformTransactionRequest
}

func (r DefaultAPIPerformtransactionRequest) PerformTransactionRequest(performTransactionRequest PerformTransactionRequest) DefaultAPIPerformtransactionRequest {
	r.performTransactionRequest = &performTransactionRequest
	return r
}

func (r DefaultAPIPerformtransactionRequest) Execute() (*PerformTransactionResponse, *http.Response, error) {
	return r.ApiService.PerformtransactionExecute(r)
}

/*
Performtransaction PerformTransaction operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPIPerformtransactionRequest
*/
func (a *DefaultAPIService) Performtransaction(ctx context.Context) DefaultAPIPerformtransactionRequest {
	return DefaultAPIPerformtransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PerformTransactionResponse
func (a *DefaultAPIService) PerformtransactionExecute(r DefaultAPIPerformtransactionRequest) (*PerformTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PerformTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Performtransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PerformTransaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.performTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("performTransactionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.performTransactionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultAPISetfiscaldataRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	setFiscalDataRequest *SetFiscalDataRequest
}

func (r DefaultAPISetfiscaldataRequest) SetFiscalDataRequest(setFiscalDataRequest SetFiscalDataRequest) DefaultAPISetfiscaldataRequest {
	r.setFiscalDataRequest = &setFiscalDataRequest
	return r
}

func (r DefaultAPISetfiscaldataRequest) Execute() (*SetFiscalDataResponse, *http.Response, error) {
	return r.ApiService.SetfiscaldataExecute(r)
}

/*
Setfiscaldata SetFiscalData operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return DefaultAPISetfiscaldataRequest
*/
func (a *DefaultAPIService) Setfiscaldata(ctx context.Context) DefaultAPISetfiscaldataRequest {
	return DefaultAPISetfiscaldataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetFiscalDataResponse
func (a *DefaultAPIService) SetfiscaldataExecute(r DefaultAPISetfiscaldataRequest) (*SetFiscalDataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetFiscalDataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Setfiscaldata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SetFiscalData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setFiscalDataRequest == nil {
		return localVarReturnValue, nil, reportError("setFiscalDataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setFiscalDataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
